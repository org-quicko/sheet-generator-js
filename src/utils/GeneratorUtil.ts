import { JsonSchema } from "../beans";
import { createRequire } from "module";

// import {version} from '../../package.json';

const require = createRequire(import.meta.url);
const pkg = require("../../package.json");

/**
 * Utility class for JSON and string manipulation operations.
 */
export class GeneratorUtil {
	/**
	 * The comment that is added to all auto-generated files.
	 */
	public static readonly AUTO_GEN_COMMENT = `// Auto-generated by @org-quicko/sheet-generator@${pkg.version}\n\n`;

	/**
	 * Capitalizes the first character of a string.
	 * @param str - The string to capitalize
	 * @returns The capitalized string
	 */
	public static capitalize(str: string): string {
		return str.charAt(0).toUpperCase() + str.slice(1);
	}

	/**
	 * Converts a snake_case string to camelCase.
	 * @param str - The snake_case string to convert
	 * @returns The camelCase string
	 */
	public static toCamelCase(str: string): string {
		return str
			.split("_")
			.map((word, index) => (index === 0 ? word : this.capitalize(word)))
			.join("");
	}

	/**
	 * Converts a PascalCase, camelCase or snake_case string to kebab-case.
	 * @param str - The string to convert
	 * @returns The kebab-case string
	 */
	public static toKebabCase(str: string): string {
		return str
			.replace(/([a-z0-9])([A-Z])/g, "$1-$2") // handle camelCase or PascalCase
			.replace(/_/g, "-") // handle snake_case
			.toLowerCase();
	}

	/**
	 * Ensures a name ends with the given suffix, handling duplicate suffixes.
	 * @param name - The base name
	 * @param suffix - The suffix to append
	 * @returns The sanitized name with proper suffix
	 */
	public static sanitizeName(name: string, suffix: string): string {
		if (name.endsWith(suffix + suffix)) {
			return name.slice(0, -suffix.length);
		}
		if (name.endsWith(suffix)) {
			return name;
		}
		return name + suffix;
	}

	/**
	 * Converts a JSON Schema type to its TypeScript equivalent.
	 * @param type - The JSON Schema type to convert
	 * @returns The corresponding TypeScript type
	 */
	public static getTypeScriptType(type: unknown): string {
		if (Array.isArray(type)) {
			return type.map((t) => this.getTypeScriptType(t)).join(" | ");
		}

		const typeMap: Record<string, string> = {
			integer: "number",
			number: "number",
			epoch: "number",
			long: "number",
			null: "null",
			string: "string",
			boolean: "boolean",
			object: "JSONObject",
			array: "JSONArray",
		};

		return typeMap[type as string] || "unknown";
	}

	/**
	 * Gets the first enum value from a JSON Schema property.
	 * @param schema - The JSON Schema object
	 * @param propertyName - Name of the property containing enums
	 * @returns The first enum value or an 'unknown' placeholder
	 */
	public static getFirstEnum(schema: JsonSchema, propertyName: string): string {
		const enumValues = schema?.properties?.[propertyName]?.enum;
		if (!enumValues?.length) {
			return `unknown_${propertyName}`;
		}
		return enumValues[0];
	}
}
